\documentclass[12pt, a4paper]{article} 
 
\usepackage[utf8]{inputenc}
 

\usepackage[bottom = 8em]{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
 
\usepackage{graphicx} % support the \includegraphics command and options
 
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{float}
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...
 
 
 
\usepackage{amsmath, amssymb}% for mathematical symbols
\usepackage[colorlinks=true,linkcolor=black]{hyperref} % for hyperreferences with black color
%\usepackage[T1]{fontenc} % Uncomment for norwegian document
%\usepackage[norsk]{babel} %
 
%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

 
%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)
 
%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!
 
 
%%% END Article customizations
 
%%% The "real" document content comes below...
 
\title{AI prog 1}
\author{Eivind HÃ¦rum \& \ Hong-Dang Lam}
\date{\today} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 
 
\begin{document}
\maketitle
%\begin{abstract}
% 
%Abstract
% 
%\end{abstract}
 
\newpage
\tableofcontents
\newpage
 
\section{Working GPS}
Please refer to the delivered code.
We have included a textfile for each problem with some strings of inputs to easily test the program for various configurations.

\section{Diagram}

\section{Third Puzzle}
Our third puzzle is Sudoku, we have however modified the rules a bit because it makes it easier to implement and we feel that this modification fits the scheme of a scaling constraint satisfaction problem better.\\
The difference between this and the normal Sudoku is the fact that the normal sudoku is usually a board of 3x3 numbered grids (with numbers ranging from and including 1 to and including 9), and the board is pre-filled with some numbers already, these numbers are not allowed to be changed whatsoever.\\
Our modified version starts out with an empty board, follows the same basic rules as the normal Sudoku (meaning there can only be one of each number inside a square, and on each row and column) but we just fill the board in an arbitrary pattern and modify a complete "solution" untill we find one solution that doesn't violate the constraints. We do this by randomly filling each "square" with numbers from 1 to k*k (for instance 1-9 for k=3 - which is the normal sudoku size found in newspapers). We then only swap numbers inside each "square", thus we need only consider conflicts on the rows and columns as the numbers inside each square already meet the contraint that only one of each number may be inside each square. This modified version makes it easy to create scaling problems, as we can simply increase $k$ and make bigger boards, thus making it much more complex and computationally harder.
\\\\
To evaluate the board at a given time, we tally up the number of conflicts for each position with their corresponding column and row, and update a totalCount of all the conflicts.
\\\\
For example if the board looks like this:

\begin{verbatim}

The board

 2  6  4     4  2  8     3  7  1 
 5  9  1     6  3  5     6  9  5 
 7  8  3     7  1  9     2  4  8 

 6  5  1     1  6  4     7  2  4 
 7  9  4     2  8  5     1  3  6 
 2  8  3     7  9  3     9  8  5 

 5  9  2     6  5  1     2  8  7 
 8  6  7     3  2  7     5  4  6 
 4  1  3     8  9  4     9  3  1 

\end{verbatim}

\noindent
Then we have a conflict matrix and a totalCount that looks like this:

\begin{verbatim}

Num of conflicts in total: 100

2 1 2 	1 2 0 	0 0 1 
3 3 1 	2 0 3 	1 1 3 
2 2 2 	2 0 0 	1 1 1 

1 0 2 	1 1 2 	0 0 1 
1 2 1 	0 0 1 	0 1 1 
1 2 3 	1 2 1 	2 2 1 

2 2 1 	1 1 0 	2 1 0 
0 2 1 	0 1 1 	0 1 2 
1 1 3 	0 2 2 	2 2 2 

\end{verbatim}
\noindent
We can for example look at the number 2 in the top leftmost square (pos(0,0)) and see that the conflict matrix states that it has 2 conflicting 2s in total, we can easily verify this by finding the 2 on the same row in the top middle square (pos(0,4)), and the 6 on the same column that is located in the middle leftmost
square (pos(5,0)).
\\
In SA this information is enough to deduce the objective function as we need only count the conflicts on the board and give an appropriate value to such a state. \\
However in Minimum-Conflicts we can use this information more intelligently and look at the conflict matrix to see where we can make a change (I.e each position where there are 1 or more conflicts), and then pick one of these at random.
\\\\
The way we have opted to choose a neighboring state with use of Minimum-Conflicts is that for the chosen position we temporarily swap with each of the other positions inside the same square, and then tally up the number of conflicts this new position will yield in total (I.e count both row and column collisions of both the new position with the chosen number and also the old position with the swapped value). This is done by keeping a squareConflict matrix represented such as this:

\begin{verbatim}

Y5X4
[1, 1, 1]
[4, 4, 4]
[1, 2, 4]

\end{verbatim}
\noindent
We see here that the position Y=5, X=4 has been chosen, i.e the algorithm will traverse the middle square and find the position to swap with that yields the least conflicts.
From the matrix we can see that the set (Y3X3, Y3X4, Y3X5, Y5X3) all yield a total of 1 conflict if swapped to (whereas the original Y5X4 yields 2). The algorithm arbitrarily chose to swap with Y3X5 (so that 9 and 4 switch places) and this is then the resulting board and conflict matrix:

\begin{verbatim}


The board

 2  6  4     4  2  8     3  7  1 
 5  9  1     6  3  5     6  9  5 
 7  8  3     7  1  9     2  4  8 

 6  5  1     1  6  9     7  2  4 
 7  9  4     2  8  5     1  3  6 
 2  8  3     7  4  3     9  8  5 

 5  9  2     6  5  1     2  8  7 
 8  6  7     3  2  7     5  4  6 
 4  1  3     8  9  4     9  3  1 


Num of conflicts in total: 94

2 1 2 	1 2 0 	0 0 1 
3 3 1 	2 0 3 	1 1 3 
2 2 2 	2 0 1 	1 1 1 

1 0 2 	1 1 1 	0 0 0 
1 2 1 	0 0 1 	0 1 1 
1 2 3 	1 0 1 	1 2 1 

2 2 1 	1 1 0 	2 1 0 
0 2 1 	0 1 1 	0 1 2 
1 1 3 	0 1 1 	2 2 2 

\end{verbatim}

\noindent 
The byproduct of this swap is that not only does the swapped values reduce their own conflicts but those previously crashed with as well, thus we manage to reduce the number of total conflicts from 100 down to 94.

\section{Demonstration of K-queen}
%Will be shown on Friday 25. October 2013.
From the assignment text k = 8 is easy, k = 25 is medium and k=1000 is hard-case, but k = 2500 has a runtime of approximately 1 min by using Minimum-Conflicts.

\section{Result table of K-queens, and a description of an easy-case}
\begin{verbatim}
QueenManager k=8
The board 
[0, 0, 0, 0, 0, 1, 0, 0]
[0, 0, 0, 1, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 1, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 1]
[0, 1, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 1, 0]
[0, 0, 1, 0, 0, 0, 0, 0]

Iterations for this run:55
Time spent on this run: 1ms
\end{verbatim}

Final statistic for 20 runs with 10000 iterations:
\begin{verbatim}
Total time spent: 45ms
Total iterations for all goal states: 745
Runs which resulted in a goal state: 20 out of 20
Run reaching a goal state with the fewest iterations: 6
Run reaching a goal state with the most iterations: 199
Average iterations per run reaching a goal state: 37.25
\end{verbatim}


\section{Demonstration of Graph-color}
%Will be shown on Friday 25. October 2013.
We have decided that number 1 is easy, 2 is medium and 3 is hard-case.  These numbers correspond to the txt file given inside the project - that is 1 corresponds to \textit{graph-color-1.txt} etc. (do note that we swapped the numbers 1 and 2 of the provided files).\\
The first "easy" one have a 40 nodes/countries and 67 edges/countries bordering each other, the second medium one have 40 nodes and 97 edges whilst the hardest problem have 500 nodes with 1009 edges.\\ 
We decided to classify these problems as such because it is more logical that the more edges and nodes you have, the harder the problem becomes. It's also the only input we have for this problem.
This problem is also known as vertex-coloring, which is a problem where you have to color every node with a color so that none of its neighbor have the same color.\\
The data we got is explained here:\\ \href{http://www.idi.ntnu.no/emner/it3105/materials/data/graph-color-format.txt}{http://www.idi.ntnu.no/emner/it3105/materials/data/graph-color-format.txt},
as you can see, these nodes are provided with coordinates. These coordinates are mostly there for the visual representation if needed, it's not needed for the actual problem, this is because there's no need for information \textbf{where} the nodes are located as long as we know how the edges are connected. For this task, we've decided to use a neighbor-matrix to represent the nodes and the edges, this is represented by a 2-dimensional boolean array where a \textit{True} indicates an edge between a node \textit{i} and node \textit{j} ($i \neq j$) and an int array which contains the colors of each node.

\section{Result table of Graph-Coloring, and the description of an easy-case}
One of the runs and its results printed out, the N indicates which node we are looking at and the C tells us which color this node is. We have used numbers to represent the colors because this is easier to work with.\\
\begin{verbatim}
GraphManager: graph-color-1.txt

num of conflicts in total: 0
N = Node C = Color
N:0 C:2| N:1 C:1 
N:1 C:1| N:0 C:2 N:2 C:0 N:3 C:3 N:4 C:2 
N:2 C:0| N:1 C:1 N:3 C:3 N:4 C:2 
N:3 C:3| N:1 C:1 N:2 C:0 N:4 C:2 
N:4 C:2| N:1 C:1 N:2 C:0 N:3 C:3 N:5 C:3 
N:5 C:3| N:4 C:2 N:6 C:0 
N:6 C:0| N:5 C:3 N:7 C:2 N:8 C:3 
N:7 C:2| N:6 C:0 N:8 C:3 N:9 C:1 N:10 C:0 
N:8 C:3| N:6 C:0 N:7 C:2 N:9 C:1 N:10 C:0 
N:9 C:1| N:7 C:2 N:8 C:3 N:10 C:0 N:11 C:2 
N:10 C:0| N:7 C:2 N:8 C:3 N:9 C:1 N:11 C:2 N:12 C:3 
N:11 C:2| N:9 C:1 N:10 C:0 N:12 C:3 
N:12 C:3| N:10 C:0 N:11 C:2 N:13 C:2 
N:13 C:2| N:12 C:3 N:14 C:3 
N:14 C:3| N:13 C:2 N:15 C:0 N:16 C:1 
N:15 C:0| N:14 C:3 N:16 C:1 N:18 C:3 
N:16 C:1| N:14 C:3 N:15 C:0 N:17 C:2 N:18 C:3 N:19 C:0 
N:17 C:2| N:16 C:1 N:18 C:3 N:19 C:0 
N:18 C:3| N:15 C:0 N:16 C:1 N:17 C:2 N:19 C:0 N:20 C:2 
N:19 C:0| N:16 C:1 N:17 C:2 N:18 C:3 N:20 C:2 N:22 C:1 
N:20 C:2| N:18 C:3 N:19 C:0 N:21 C:0 N:22 C:1 
N:21 C:0| N:20 C:2 N:22 C:1 
N:22 C:1| N:19 C:0 N:20 C:2 N:21 C:0 N:23 C:2 
N:23 C:2| N:22 C:1 N:24 C:3 N:26 C:0 
N:24 C:3| N:23 C:2 N:25 C:1 N:26 C:0 
N:25 C:1| N:24 C:3 N:26 C:0 N:27 C:3 
N:26 C:0| N:23 C:2 N:24 C:3 N:25 C:1 N:27 C:3 
N:27 C:3| N:25 C:1 N:26 C:0 N:28 C:0 N:29 C:1 N:30 C:2 
N:28 C:0| N:27 C:3 N:29 C:1 N:30 C:2 N:31 C:3 
N:29 C:1| N:27 C:3 N:28 C:0 N:30 C:2 N:31 C:3 
N:30 C:2| N:27 C:3 N:28 C:0 N:29 C:1 N:31 C:3 
N:31 C:3| N:28 C:0 N:29 C:1 N:30 C:2 N:32 C:2 
N:32 C:2| N:31 C:3 N:33 C:0 N:34 C:1 
N:33 C:0| N:32 C:2 N:34 C:1 N:35 C:2 
N:34 C:1| N:32 C:2 N:33 C:0 N:35 C:2 
N:35 C:2| N:33 C:0 N:34 C:1 N:36 C:1 
N:36 C:1| N:35 C:2 N:37 C:3 
N:37 C:3| N:36 C:1 N:38 C:2 N:39 C:1 
N:38 C:2| N:37 C:3 N:39 C:1 
N:39 C:1| N:37 C:3 N:38 C:2 

\end{verbatim}
\noindent
Final statistic for 20 runs with a maximum of 10000 iterations for min-conflict (there is no need to include average and standard deviation for evaluation as it solves everything each run):\\

\begin{center}
  \begin{tabular}{| l | c c c|}
    \hline
    Hardness: &\textbf{Easy} & \textbf{Medium} & \textbf{Hard} \\ \hline
    Average iterations reaching goal: & 21.45& 104.95& 646.4\\
    Average iteration per run:  & 21.45 & 104.95 &  646.4\\
    Standard deviation for iterations $\sigma$ & 10.14 & 42.96 & 67.16\\
    Fewest iterations: & 11 & 45& 493\\ 
    Most iterations: & 59 & 191& 766\\ 
    Number of goal states reached: & 20/20 & 20/20 & 20/20\\
    Total iterations: & 429 & 2099& 12928\\
    Total iterations for goal states: & 429 & 2099& 12928\\
    Total time spent: & 97ms& 149ms & 9336ms\\
    \hline
  \end{tabular}
\end{center}


\section{Demonstration of the modified Sudoku}
%Will be shown on Friday 25. October 2013.
We have decided that k = 2 is easy case, 3 is medium, 9 is hard. 
We have decided to use these \textit{k}s because of the runtime, the k for the hard problem runs in X minutes - which is what the assignment text wants the runtime of a hard problem to be.

\section{Result table of modified Sudoku, and description of an easy-case}
\begin{verbatim}
The board

 4  2     1  3 
 1  3     2  4 

 3  1     4  2 
 2  4     3  1 
 
Iterations for this run:9
Time spent on this run: 1ms
\end{verbatim}

\noindent
Final statistic for 20 runs with a maximum of 10000 iterations:

\begin{verbatim}
Total time spent: 27ms
Total iterations for all goal states: 132
Runs which resulted in a goal state: 20 out of 20
Run reaching a goal state with the fewest iterations: 2
Run reaching a goal state with the most iterations: 14
Average iterations per run reaching a goal state: 6.6

\end{verbatim}
\end{document}